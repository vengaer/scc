= scc_svec
:toc:
:toclevels: 2
:source-highlighter: rouge
:source-language: c

`scc_svec` provides a generic "short" vector particularly suitable for working with smaller sets of elements. The initial structure is
allocated with automatic storage duration, allowing smaller vectors do avoid dynamic allocation altogether. Should more space than what
is allocated in the initial structure be required, the vector is moved to the heap.
Unless having a specific reason for avoiding placing data on the stack, `scc_svec` should almost always be preferred to `scc_vec`.

Overall, the interface is similar to that provided by `scc_vec`. Notably, individual elements may be accessed using regular indexing with `[]`.

Note that, despite the similarities between their APIs, `scc_svec` and `scc_vec` cannot be used interchangeably. Each must used with its own
associated functions.

.Example usage
[source]
----
include::snips/scc_svec_example.csnip[tags=scc_svec_example]
----

== Construction and Deallocation

=== void *scc_svec_init(type)

Returns address of an empty `scc_svec` structure with automatic storage duration. `type` is the type of the elements to be stored in the vector.
The initial capacity of the `scc_svec` is `SCC_SVEC_STATIC_CAPACITY` elements. This capacity  may be altered by defining `SCC_SVEC_STATIC_CAPACITY` before including `scc_svec.h`.

The returned pointer should be assigned to a pointer to `type`. Furthermore, while `scc_svec_init` never performs any dynamic allocations, this pointer should always be passed to `scc_svec_free` once done with the structure.

==== Returns

Address of an empty `scc_svec` instance with automatic storage duration.

=== void scc_svec_free(void *svec)

Reclaim memory allocated for `vec`. Should be passed only pointers returned by `scc_svec_init`.

Once the call to `scc_svec_free` returns, the memory referenced by the `svec` parameter should be treated as
invalid. If the variable is to be reused as another vector, it must be reinitialized using `scc_svec_init`.

== Capacity

=== size_t scc_svec_size(void const *svec)

Get the number of elements currently held in the vector. Must only be called on pointers initialized using `scc_svec_init`.

==== Returns

The number of elements in the vector.

=== size_t scc_svec_capacity(void const *svec)

Get the maximum number of elements the vector is currently able to store. Must only be called on pointers initialized using `scc_svec_init`.

==== Returns

The maximum number of elements the vector can store at the time of the call.


=== bool scc_svec_reserve(void *svec, size_t capacity)

Resizes the vector such that it is capable of storing at least `capacity` elements. The `svec` must be passed as a pointer
to a complete type, see the listing below for details.

`scc_svec_reserve` may relocate the vector in memory. As such, any other pointers to it, or its elements, should be
considered invalid after a reserve call.

If the capacity of the vector is already greater than the one requested as the `capacity` parameter, the call returns
immediately.

If memory allocation fails, the vector remains unchanged and must still be passed to `scc_svec_free` for deallocation.

==== Returns

* `true` if enough memory could be reserved, or the vector's capacity is already larger than requested
* `false` on allocation failure

==== Argument Passing

The `svec` argument passed to `scc_svec_reserve` must be a pointer to a complete type. See the examples under `scc_vec_reserve` link:scc_vec.html[here].
