= scc_svec
:toc:
:toclevels: 2
:source-highlighter: rouge
:source-language: c

`scc_svec` provides a generic "short" vector particularly suitable for working with smaller sets of elements. The initial structure is
allocated with automatic storage duration, allowing smaller vectors do avoid dynamic allocation altogether. Should more space than what
is allocated in the initial structure be required, the vector is moved to the heap.
Unless having a specific reason for avoiding placing data on the stack, `scc_svec` should almost always be preferred to `scc_vec`.

Overall, the interface is similar to that provided by `scc_vec`. Notably, individual elements may be accessed using regular indexing with `[]`.

Note that, despite the similarities between their APIs, `scc_svec` and `scc_vec` cannot be used interchangeably. Each must used with its own
associated functions.

.Example usage
[source]
----
include::snips/scc_svec_example.csnip[tags=scc_svec_example]
----

== Construction and Deallocation

=== void *scc_svec_init(type)

Returns address of an empty `scc_svec` structure with automatic storage duration. `type` is the type of the elements to be stored in the vector.
The initial capacity of the `scc_svec` is `SCC_SVEC_STATIC_CAPACITY` elements. This capacity  may be altered by defining `SCC_SVEC_STATIC_CAPACITY` before including `scc_svec.h`.

The returned pointer should be assigned to a pointer to `type`. Furthermore, while `scc_svec_init` never performs any dynamic allocations, this pointer should always be passed to `scc_svec_free` once done with the structure.

==== Returns

Address of an empty `scc_svec` instance with automatic storage duration.

=== void *scc_svec_from(type, type... args)

Initialize an `scc_svec` for storing instances of `type` initialized with `args`. At least one argument must be passed in `args`.
Failure to do so will usually result in warnings but does compile. If more arguments than fit in the static buffer are passed, the
call results in exactly enough space to store the passed `args` being allocated. The returned pointer must be passed to
`scc_svec_free` for the memory to be released.

If the number of elements passed in `args` is smaller than `SCC_SVEC_STATIC_CAPACITY`, the call always succeeds.

==== Returns

- `NULL` on allocation failure
- Address of an `scc_svec` containing `args` otherwise.

`scc_svec_from` is to be preferred over combinations of `scc_svec_init`, `scc_svec_reserve` and `scc_svec_push` as
it allows for more optimizations. The difference between the two approaches is smaller than the difference when
using `scc_vec`, though.

.Example usage
[source]
----
include::snips/scc_svec_from.csnip[tags=scc_vec_from]
----

==== Implementation Limitations

The `args` parameter can contain at least 126 parameters (not counting the initial `type`) when scc is compiled with a standard-compliant compiler. The number may be even larger in practice.

=== void scc_svec_free(void *svec)

Reclaim memory allocated for `vec`. Should be passed only pointers returned by `scc_svec_init`.

Once the call to `scc_svec_free` returns, the memory referenced by the `svec` parameter should be treated as
invalid. If the variable is to be reused as another vector, it must be reinitialized using `scc_svec_init`.

== Capacity

=== bool scc_svec_empty(void const *vec)

Check whether the vector is empty.

==== Returns
* `true` if `scc_svec_size(vec) == 0`
* `false` otherwise

=== size_t scc_svec_size(void const *svec)

Get the number of elements currently held in the vector. Must only be called on pointers initialized using `scc_svec_init`.

==== Returns

The number of elements in the vector.

=== size_t scc_svec_capacity(void const *svec)

Get the maximum number of elements the vector is currently able to store. Must only be called on pointers initialized using `scc_svec_init`.

==== Returns

The maximum number of elements the vector can store at the time of the call.


=== bool scc_svec_reserve(void *svec, size_t capacity)

Resizes the vector such that it is capable of storing at least `capacity` elements. The `svec` must be passed as a pointer
to a complete type, see the listing below for details.

`scc_svec_reserve` may relocate the vector in memory. As such, any other pointers to it, or its elements, should be
considered invalid after a reserve call.

If the capacity of the vector is already greater than the one requested as the `capacity` parameter, the call returns
immediately.

If memory allocation fails, the vector remains unchanged and must still be passed to `scc_svec_free` for deallocation.

==== Returns

* `true` if enough memory could be reserved, or the vector's capacity is already larger than requested
* `false` on allocation failure

==== Argument Passing

The `svec` argument passed to `scc_svec_reserve` must be a pointer to a complete type. See the examples under `scc_vec_reserve` link:scc_vec.html[here].

== Modifiers

=== void scc_svec_clear(void *svec)

Empties the vector by setting its size to 0 while leaving its capacity unchanged.

=== bool scc_svec_resize(void *svec, size_t size)

Resizes the vector to contain `size` elements, allocating more memory if required. The following three cases may occur

* If `scc_svec_size(vec) == size` or `size == 0`, the function returns immediately. No allocations are performed.
* If `scc_svec_size(vec) > size`, the size of the vector is truncated to `size`. No allocations are performed.
* If `scc_svec_size(vec) < size`, the vector is resized such that it can hold at least `size` elements. Newly inserted elements are zeroed. Subsequent calls to `scc_svec_size` not preceded by other calls that may alter the vector return `size`. Memory is allocated dynamically only if `size` is larger than `SCC_SVEC_STATIC_CAPACITY`.

==== Returns
* `true` if the vector was successfully resized
* `false` on allocation error

=== bool scc_svec_push(void *svec, type value)

Push `value` onto the back of the vector, allocating more memory if required. `svec` is expected to be of type pointer to `type` (i.e. `type *`).

In the event of memory allocation failure, `false` is returned and the vector is left in the state it was before the call to `scc_svec_reserve`. Regardless of whether the call succeeds or not, the vector must be freed using `scc_svec_free`.

==== Returns

* `true` if the value was successfully added to the vector
* `false` on allocation failure

=== void scc_svec_pop(void *svec)

Pop the last element from the vector (i.e. decrement the size of the vector by one).  No bounds checking is performed.

=== void scc_svec_pop_safe(void *svec)

Like `scc_svec_pop` but with bounds checking. If attempting to pop from an empty vector, standard `exit` is called.

=== void scc_svec_erase(void *svec, void *iter)

Erase the element at address `iter`, the latter must refer to a suitably aligned address in `svec`. No bounds checking
is performed. Requires that all elements located at addresses beyond `iter` are copied to replace it.

.Erasing the 3rd element in a vector
[source]
----
include::snips/scc_svec_erase.csnip[tags=scc_vec_erase]
----

=== void scc_svec_erase_range(void *svec, void *first, void const *end)

Erase the elements at addresses in range `[first,end)`. Elements in the range `[end,&svec[scc_svec_size(svec)])` are copied
to replace the erased range. `first` must refer to a suitably aligned address in `svec`. `end` must be either an address in
`svec` or `&svec[scc_svec_size(vec)]`. It is subject to the same alignment requirements as `first`.

If `first <= end`, the function returns immediately.

.Erasing 3 elements at offset 8
----
include::snips/scc_svec_erase_range.csnip[tags=scc_vec_erase]
----

== Accessors

=== type operator[](void *svec, size_t index)

Returns the element at slot `index` in the vector. No bounds checking is performed. `svec` is expected to be passed as a pointer to `type`, i.e. `type *`.

==== Returns

The element at slot `index`.
