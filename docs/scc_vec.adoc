= scc_vec
:toc:
:toclevels: 1
:source-highlighter: rouge
:source-language: c

`scc_vec` is a generic, dynamically allocated array. Individual elements of the vector
may be accessed using `[]` as if it were a regular array.

== void *scc_vec_init(void)

Initialize an empty `scc_vec` structure. While the call itself never allocates, the
returned pointer should always be passed `scc_vec_free` to reclaim potential memory
allocated as part of calls to other parts of the API. Passing the vector to standard
`free` will result in heap corruption.

The returned pointer should be assigned to a pointer to a
non-incomplete type to enforce type safety.

=== Returns

Address of an empty, initialized vector structure.

=== Initializing Arbitrary Vectors

The type of the vector is determined by the pointer used to store it. If that pointer is a
pointer to `int`, the vector is treated as a vector of `int`. If the pointer is instead
a pointer to `double`, the vector is treated as a vector of `double`.

As an example, initializing a vector of `int` is done as follows

.Initializing a vector of integers
[source]
----
int *vec = scc_vec_init();
----

The above pattern may be applied to any arbitrary type. Creating a vector of a user-defined
`struct point` is as simple as

.Initializing a vector of a user-defined type
[source]
----
struct point {
    float x;
    float y;
};

struct point *vec = scc_vec_init();
----

== void scc_vec_free(void *vec)

Free the memory occupied by `vec`. May only be called on pointers initialized with `scc_vec_init`.

Once the call to `scc_vec_free` returns, the memory reference by the `vec` parameter should be treated as
invalid. If the variable is to be reused as another vector, it must be reinitialized using `scc_vec_init`.

== size_t scc_vec_size(void const *vec)

Get the number of elements currently held in the vector. Must only be called on elements initialized using
`scc_vec_init`.

=== Returns

The number of elements in the vector.

== size_t scc_vec_capacity(void const *vec)

Get the maximum number of elements the vector is currently able to store. Must only be called on elements
initialized using `scc_vec_init`.

=== Returns

The maximum number of elements the vector can store at the time of the call.

== bool scc_vec_reserve(void *vec, size_t capacity)

Resizes the vector such that it is capable of storing at least `capacity` elements. The `vec` must be passed as a pointer
to a non-incomplete type, see the listing below for details.

`scc_vec_reserve` may relocate the vector in memory. As such, any other pointers to it, or its elements, should be
considered invalid after a reserve call.

If the capacity of the vector is already larger than the one requested as the `capacity` parameter, the call returns
immediately.

If memory allocation fails, the vector remains unchanged and must still be passed to `scc_vec_free` for deallocation.

=== Returns

* `true` if enough memory could be reserved, or the vector's capacity is already larger than the requested one.
* `false` on allocation failure

=== Argument Passing

The `vec` argument passed to `scc_vec_reserve` must be a pointer to a non-incomplete type. Notably, it may *not* be
passed as `void *` as there would be no way to determine the required size in bytes. While attempting to pass a
pointer to an incomplete type will usually result in either a compilation error or, at least, warnings, this should not
be relied upon.

.Complete and incomplete parameter passing
[source]
----
int *v = scc_vec_init();

/* Valid, v is passed as a pointer to int */
if(!scc_vec_reserve(v, 32)) {
    exit(1);
}
/* ... */
scc_vec_free(v);

v = scc_vec_init();
/* Invalid, passing pointer to incomplete type. */
if(!scc_vec_reserve((void *)v, 32)){
    exit(1);
}

/* Invalid, results in sizeof(void). Typically a warning, but not guaranteed */
if(!scc_vec_reserver((void *){ v }, 32)) {
    exit(1);
}
----

== bool scc_vec_push(void *vec, T value)

Push `value` onto the back of the vector, allocating more memory if required. `vec` is expected to be of type
pointer to `T`.

If the vector had to be resized and memory allocation failed, the vector is left unchanged, its address, size,
capacity and held values identical to what they were before the call. Regardless of whether a call to
`scc_vec_push` succeeds or not, the vector must be passed to `scc_vec_free` to reclaim the allocated memory.

=== Returns
* `true` if the value was successfully added to the vector
* `false` on allocation failure

== void scc_vec_pop(void *vec)

Pop the last element from the vector.  No bounds checking is performed.
