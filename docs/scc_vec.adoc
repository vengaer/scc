= scc_vec
:toc:
:toclevels: 2
:source-highlighter: rouge
:source-language: c

`scc_vec` is a generic, dynamically allocated array. Individual elements of the vector
may be accessed using `[]`.

Note that, despite the similarities between their APIs, `scc_vec` and `scc_svec` cannot be used interchangeably. Each must used with its own
associated functions.

The following shows an example of how the vector may be used

.Example usage
[source]
----
include::snips/scc_vec_example.csnip[tags=scc_vec_example]
----

== Construction and Dellocation

=== void *scc_vec_init(type)

Initialize an empty `scc_vec` structure for storing objects of `type`. While the call
itself never allocates, the returned pointer should always be passed `scc_vec_free` to
reclaim potential memory allocated during calls to other parts of the API. Passing the
vector to standard `free` will result in heap corruption.

The returned pointer should be assigned to a pointer to `type`.

==== Returns

Address of an empty, initialized vector structure with automatic storage duration.

==== Initializing Arbitrary Vectors

The type of the vector is determined by the pointer used to refer to it. If that pointer is a
pointer to `int`, the vector is treated as a vector of `int` If the pointer is instead
a pointer to `double`, the vector is treated as a vector of `double`. This is the case
regardless of what `type` was passed to `scc_vec_init`. It is therefore vital that the two
are kept consistent.

As an example, initializing a vector of `int` is done as follows

.Initializing a vector of integers
[source]
----
include::snips/scc_vec_init_int.csnip[tags=scc_vec_init_int]
----

The above pattern may be applied to any arbitrary type. Creating a vector of a user-defined
`struct point` is as simple as

.Initializing a vector of a user-defined type
[source]
----
include::snips/scc_vec_init_point.csnip[tags=scc_vec_init_point]
----

=== void *scc_vec_from(type, type... args)

Initialize an `scc_vec` for storing instance of `type` initialized with `args`. At least one argument must be passed in `args`.
Failure to do so will usually result in warnings but does compile. The call allocates exactly enough space to store the
passed `args`. The returned pointer must be passed to `scc_vec_free` for the memory to be released.

==== Returns

- `NULL` on allocation failure
- Address of a dynamically allocated `scc_vec` containing `args` otherwise

When possible, `scc_vec_from` should always be preferred to combinations of `scc_vec_init`, `scc_vec_reserve` and `scc_vec_push` as
it both allows for more optimizations and saves on stack space.

While the following two snippets produce the same observable result. Initializing the vector all in one go using

.Initializing the vector all at once
[source]
----
include::snips/scc_vec_from.csnip[tags=scc_vec_from]
----

is more efficient than

.Hand-rolled vector initialization
[source]
----
include::snips/scc_vec_from_emulation.csnip[tags=scc_vec_from_emulation]
----

==== Implementation Limitations

The `args` parameter can contain up to at least 126 parameters (not counting the initial `type`) when scc is compiled with a standard-compliant compiler. The number may be even larger in practice.

=== void scc_vec_free(void *vec)

Free the memory used by `vec`. May only be called on pointers returned from either `scc_vec_init` or `scc_vec_from`.

Once the call to `scc_vec_free` returns, the memory referenced by the `vec` parameter should be treated as
invalid. If the variable is to be reused as another vector, it must be reinitialized using `scc_vec_init` or
`scc_vec_from`.

== Capacity

=== bool scc_vec_empty(void const *vec)

Check whether the vector is empty.

==== Returns
* `true` if `scc_vec_size(vec) == 0`
* `false` otherwise

=== size_t scc_vec_size(void const *vec)

Get the number of elements currently held in the vector. Must only be called on pointers initialized using
`scc_vec_init` or `scc_vec_from`.

==== Returns

The number of elements in the vector.

=== size_t scc_vec_capacity(void const *vec)

Get the maximum number of elements the vector is currently able to store. Must only be called on pointers
initialized using `scc_vec_init` or `scc_vec_from`.

==== Returns

The maximum number of elements the vector can store at the time of the call.

=== bool scc_vec_reserve(void *vec, size_t capacity)

Resizes the vector such that it is capable of storing at least `capacity` elements. The `vec` must be passed as a pointer
to a complete type, see the listing below for details.

`scc_vec_reserve` may relocate the vector in memory. As such, any other pointers to it, or its elements, should be
considered invalid after a reserve call.

If the capacity of the vector is already greater than the one requested as the `capacity` parameter, the call returns
immediately.

If memory allocation fails, the vector remains unchanged and must still be passed to `scc_vec_free` for deallocation.

==== Returns

* `true` if enough memory could be reserved, or the vector's capacity is already larger than requested
* `false` on allocation failure

==== Argument Passing

The `vec` argument passed to `scc_vec_reserve` must be a pointer to a complete type, e.g.

.Passing correct vector argument
[source]
----
include::snips/scc_vec_reserve.csnip[tags=scc_vec_reserve]
----

Notably, the `vec` parameter may *not* be passed as `void *` as there would be no way to determine the required size in bytes. While attempting to pass a pointer to an incomplete type will usually result in either a compilation error or, at least, warnings, this should not be relied upon.

.Passing incorrect vector arguments
[source]
----
int *v = scc_vec_init(int);
/* Invalid, passing pointer to incomplete type. */
if(!scc_vec_reserve((void *)v, 32)){
    exit(1);
}

/* Invalid, results in sizeof(void). Typically a warning, but not guaranteed */
if(!scc_vec_reserve((void *){ v }, 32)) {
    exit(1);
}
----

== Modifiers

=== void scc_vec_clear(void *vec)

Empties the vector by setting its size to 0. The capacity remains unchanged.

=== bool scc_vec_resize(void *vec, size_t size)

Resizes the vector to contain `size` elements, allocating more memory if required. The following three cases may occur

* If `scc_vec_size(vec) == size` or `size == 0`, the function returns immediately. No allocations are performed.
* If `scc_vec_size(vec) > size`, the size of the vector is truncated to `size`. No allocations are performed.
* If `scc_vec_size(vec) < size`, the vector is resized such that it can hold at least `size` elements. Newly inserted elements are zeroed. Subsequent calls to `scc_vec_size` not preceded by other calls that may alter the vector return `size`.

==== Returns
* `true` if the vector was successfully resized
* `false` on allocation error

=== bool scc_vec_push(void *vec, type value)

Push `value` onto the back of the vector, allocating more memory if required. `vec` is expected to be of type
pointer to `type`.

If the vector had to be resized and memory allocation failed, the vector is left unchanged, its address, size,
capacity and held values identical to what they were before the call. Regardless of whether a call to
`scc_vec_push` succeeds or not, the vector must be passed to `scc_vec_free` to reclaim the allocated memory.

==== Returns
* `true` if the value was successfully added to the vector
* `false` on allocation failure

=== void scc_vec_pop(void *vec)

Pop the last element from the vector (i.e. decrement the size of the vector by one).  No bounds checking is performed.

=== void scc_vec_pop_safe(void *vec)

Like `scc_vec_pop` but with bounds checking. If attempting to pop from an empty vector, standard `exit` is called.

=== void scc_vec_erase(void *vec, void *iter)

Erase the element at address `iter`, the latter must refer to a suitably aligned address in `vec`. No bounds checking
is performed. Requires that all elements located at addresses beyond `iter` are copied to replace it.

.Erasing the 10th element in a vector
[source]
----
include::snips/scc_vec_erase.csnip[tags=scc_vec_erase]
----

=== void scc_vec_erase_range(void *vec, void *first, void *end)

Erase the elements at addresses in range `[first,end)`. Elements in the range `[end,&vec[scc_vec_size(vec)])` are copied
to replace the erased range. `first` must refer to a suitably aligned address in `vec`. `end` must be either an address in
`vec` or `&vec[scc_vec_size(vec)]`. It is subject to the same alignment requirements as `first`.

If `first <= end`, the function returns immediately.

.Erasing 8 elements at offset 13
----
include::snips/scc_vec_erase_range.csnip[tags=scc_vec_erase]
----

== Accessors

=== type operator[](void *vec, size_t index)

Returns the element at slot `index` in the vector. No bounds checking is performed.

==== Returns

The element at slot `index`

=== type scc_vec_at(void *vec, size_t index)

Returns the element at slot `index` in the vector. If there are not enough elements in the vector, standard `exit` is called.

==== Returns
The element at slot `index`

== Convenience Macros
=== scc_vec_foreach(void *iter, void *vec)

Produces a scope executed `scc_vec_size(vec)` times with `iter` referring to each element in the vector, in order.

.Printing a vector of integers
[source]
----
include::snips/scc_vec_foreach.csnip[tags=scc_vec_foreach]
----

The above snippet produces the following output.

.Example output
[source]
----
Vector contents:
1
2
3
----


=== scc_vec_foreach_reversed(void *iter, void *vec)

Produces a scope executed `scc_vec_size(vec)` times with `iter` referring to each element in the vector in reverse order.

.Printing a vector of doubles in reverse
[source]
----
include::snips/scc_vec_foreach_reversed.csnip[tags=scc_vec_foreach_reversed]
----

.Example output
[source]
----
0.000000
12.800000
2.300000
----

=== scc_vec_foreach_by(void *iter, void *vec, size_t by)

Iterates over `vec` with `iter` referring to every `by` element.

.Printing every other element in a vector of integers
[source]
----
include::snips/scc_vec_foreach_by.csnip[tags=scc_vec_foreach_by]
----

.Example output
[source]
----
8
7
----

=== scc_vec_foreach_reversed_by(void *iter, void *vec, size_t by)

Iterator over `vec` in reverse order with `iter` referring to every `by` element.

.Printing every sixth element in a vector in reverse order
[source]
----
include::snips/scc_vec_foreach_reversed_by.csnip[tags=scc_vec_foreach_reversed_by]
----

.Example output
[source]
----
11
5
----
