= scc_vec
:toc:
:toclevels: 2
:source-highlighter: rouge
:source-language: c

`scc_vec` is a generic, dynamically allocated array. Individual elements of the vector
may be accessed using `[]` as if it were a regular array.

The following shows an example of how the vector may be used

.Example usage
[source]
----
include::snips/scc_vec_example.csnip[tags=scc_vec_example]
----

== Construction and Dellocation

=== void *scc_vec_init(void)

Initialize an empty `scc_vec` structure. While the call itself never allocates, the
returned pointer should always be passed `scc_vec_free` to reclaim potential memory
allocated as part of calls to other parts of the API. Passing the vector to standard
`free` will result in heap corruption.

The returned pointer should be assigned to a pointer to a
non-incomplete type to enforce type safety.

==== Returns

Address of an empty, initialized vector structure.

==== Initializing Arbitrary Vectors

The type of the vector is determined by the pointer used to store it. If that pointer is a
pointer to `int`, the vector is treated as a vector of `int`. If the pointer is instead
a pointer to `double`, the vector is treated as a vector of `double`.

As an example, initializing a vector of `int` is done as follows

.Initializing a vector of integers
[source]
----
include::snips/scc_vec_init_int.csnip[tags=scc_vec_init_int]
----

The above pattern may be applied to any arbitrary type. Creating a vector of a user-defined
`struct point` is as simple as

.Initializing a vector of a user-defined type
[source]
----
include::snips/scc_vec_init_point.csnip[tags=scc_vec_init_point]
----

=== void scc_vec_free(void *vec)

Free the memory occupied by `vec`. May only be called on pointers initialized with `scc_vec_init`.

Once the call to `scc_vec_free` returns, the memory reference by the `vec` parameter should be treated as
invalid. If the variable is to be reused as another vector, it must be reinitialized using `scc_vec_init`.

== Capacity

=== bool scc_vec_empty(void const *vec)

Check whether the vector is empty.

==== Returns
* `true` if `scc_vec_size(vec) == 0`
* `false` otherwise

=== size_t scc_vec_size(void const *vec)

Get the number of elements currently held in the vector. Must only be called on elements initialized using
`scc_vec_init`.

==== Returns

The number of elements in the vector.

=== size_t scc_vec_capacity(void const *vec)

Get the maximum number of elements the vector is currently able to store. Must only be called on elements
initialized using `scc_vec_init`.

==== Returns

The maximum number of elements the vector can store at the time of the call.

=== bool scc_vec_reserve(void *vec, size_t capacity)

Resizes the vector such that it is capable of storing at least `capacity` elements. The `vec` must be passed as a pointer
to a non-incomplete type, see the listing below for details.

`scc_vec_reserve` may relocate the vector in memory. As such, any other pointers to it, or its elements, should be
considered invalid after a reserve call.

If the capacity of the vector is already larger than the one requested as the `capacity` parameter, the call returns
immediately.

If memory allocation fails, the vector remains unchanged and must still be passed to `scc_vec_free` for deallocation.

==== Returns

* `true` if enough memory could be reserved, or the vector's capacity is already larger than the requested one.
* `false` on allocation failure

==== Argument Passing

The `vec` argument passed to `scc_vec_reserve` must be a pointer to a non-incomplete type, e.g.

.Passing correct vector argument
[source]
----
include::snips/scc_vec_reserve.csnip[tags=scc_vec_reserve]
----

Notably, the `vec` parameter may *not* be passed as `void *` as there would be no way to determine the required size in bytes. While attempting to pass a pointer to an incomplete type will usually result in either a compilation error or, at least, warnings, this should not be relied upon.

.Passing incorrect vector arguments
[source]
----
int *v = scc_vec_init();
/* Invalid, passing pointer to incomplete type. */
if(!scc_vec_reserve((void *)v, 32)){
    exit(1);
}

/* Invalid, results in sizeof(void). Typically a warning, but not guaranteed */
if(!scc_vec_reserver((void *){ v }, 32)) {
    exit(1);
}
----

== Modifiers

=== void scc_vec_clear(void *vec)

Empties the vector by setting its size to 0. The capacity remains unchanged.

=== bool scc_vec_resize(void *vec, size_t size)

Resizes the vector to contain `size` elements, allocating more memory if required. The following three cases may occur

* If `scc_vec_size(vec) == size` or if `size == 0`, the function returns immediately. No allocations are performed.
* If `scc_vec_size(vec) > size`, the size of the vector is set to `size`. No allocations are performed.
* If `scc_vec_size(vec) < size`, the vector is resized such that it can hold at least `size` elements. Newly inserted elements are zeroed.

==== Returns
* `true` if the vector was successfully resized
* `false` on allocation error

=== bool scc_vec_push(void *vec, T value)

Push `value` onto the back of the vector, allocating more memory if required. `vec` is expected to be of type
pointer to `T`.

If the vector had to be resized and memory allocation failed, the vector is left unchanged, its address, size,
capacity and held values identical to what they were before the call. Regardless of whether a call to
`scc_vec_push` succeeds or not, the vector must be passed to `scc_vec_free` to reclaim the allocated memory.

==== Returns
* `true` if the value was successfully added to the vector
* `false` on allocation failure

=== void scc_vec_pop(void *vec)

Pop the last element from the vector.  No bounds checking is performed.

=== void scc_vec_pop_safe(void *vec)

Like `scc_vec_pop` but with bounds checking. If attempting to pop from an empty vector, standard `exit` is called.

=== void scc_vec_erase(void *vec, void *iter)

Erase the element at address `iter`, the latter must refer to a suitably aligned address in `vec`. No bounds checking
is performed. Requires that all elements located at addresses beyond `iter` are copied to replace it.

.Erasing the 10th element in a vector
[source]
----
include::snips/scc_vec_erase.csnip[tags=scc_vec_erase]
----

=== void scc_vec_erase_range(void *vec, void *first, void *end)

Erase the elements at addresses in range `[first,end)`. Elements in the range `[end,&vec[scc_vec_size(vec)])` are copied
to replace the erased range. `first` must refer to a suitably aligned address in `vec`. `end` must be either an address in
`vec` or `&vec[scc_vec_size(vec)]`. It is subject to the same alignment requirements as `first`.

If `first <= end`, the function returns immediately.

.Erasing 8 elements at offset 13
----
include::snips/scc_vec_erase_range.csnip[tags=scc_vec_erase]
----

== Accessors

=== T operator[](void *vec, size_t index)

Returns the element at slot `index` in the vector. No bounds checking is performed.

==== Returns

The element at slot `index`

=== T scc_vec_at(void *vec, size_t index)

Returns the element at slot `index` in the vector. If there are not enough elements in the vector, standard `exit` is called.

==== Returns
The element at slot `index`

== Convenience Macros
=== scc_vec_foreach(void *iter, void *vec)

Produces a scope executed `scc_vec_size(vec)` times with `iter` referring to each element in the vector, in order.

.Printing a vector of integers
[source]
----
include::snips/scc_vec_foreach.csnip[tags=scc_vec_foreach]
----

=== scc_vec_foreach_reversed(void *iter, void *vec)

Produces a scope executed `scc_vec_size(vec)` times with `iter` referring to each element in the vector in reverse order.

.Printing a vector of doubles in reverse
[source]
----
include::snips/scc_vec_foreach_reversed.csnip[tags=scc_vec_foreach_reversed]
----

=== scc_vec_foreach_by(void *iter, void *vec, size_t by)

Iterates over `vec` with `iter` referring to every `by` element.

.Printing every other element in a vector of integers
[source]
----
include::snips/scc_vec_foreach_by.csnip[tags=scc_vec_foreach_by]
----

=== scc_vec_foreach_reversed_by(void *iter, void *vec, size_t by)

Iterator over `vec` in reverse order with `iter` referring to every `by` element.

.Printing every sixth element in a vector in reverse order
[source]
----
include::snips/scc_vec_foreach_reversed_by.csnip[tags=scc_vec_foreach_reversed_by]
----
